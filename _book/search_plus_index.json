{"./":{"url":"./","title":"简介","keywords":"","body":"简介 Python面试 "},"chapter1/readme.html":{"url":"chapter1/readme.html","title":"第1章 课程导学","keywords":"","body":"第1章 课程导学 课程导学 "},"chapter1/1.1.html":{"url":"chapter1/1.1.html","title":"1.1 Python服务端工程师面试指导","keywords":"","body":"1.1 Python服务端工程师面试指导 面试技巧篇 Python语言篇 算法与数据结构篇 编程范式篇 操作系统篇 网络编程篇 数据库篇 Web框架篇 系统设计篇 面试经验篇 "},"chapter2/readme.html":{"url":"chapter2/readme.html","title":"第2章 面试流程介绍","keywords":"","body":"第2章 面试流程介绍 面试流程介绍 "},"chapter2/2.1.html":{"url":"chapter2/2.1.html","title":"2.1 Python后端职位分析","keywords":"","body":"2.1 Python后端职位分析 略 "},"chapter2/2.2.html":{"url":"chapter2/2.2.html","title":"2.2 面试流程和环节","keywords":"","body":"2.2 面试流程和环节 学生重基础，社招重项目 一面问基础 二面问项目 三面问设计 "},"chapter2/2.3.html":{"url":"chapter2/2.3.html","title":"2.3 Python后端技术栈","keywords":"","body":"2.3 Python后端技术栈 略 "},"chapter2/2.4.html":{"url":"chapter2/2.4.html","title":"2.4 Python初中级工程师技能要求","keywords":"","body":"2.4 Python初中级工程师技能要求 略 "},"chapter2/2.5.html":{"url":"chapter2/2.5.html","title":"2.5 简历书写与自我介绍","keywords":"","body":"2.5 简历书写与自我介绍 略 "},"chapter2/2.6.html":{"url":"chapter2/2.6.html","title":"2.6 行为面试常见问题与回答技巧","keywords":"","body":"2.6 行为面试常见问题与回答技巧 START模型 情境：什么情况下发生的 任务：你是如何明确你的任务的 行动：采取了什么样的行动 结果：结果是怎么样的？学到了什么？ 你还有什么要问我的吗？ 表现出兴趣：问问工作内容（业务）、技术栈、团队、项目等 问自己的感兴趣的问题，比如架构问题 "},"chapter2/2.7.html":{"url":"chapter2/2.7.html","title":"2.7 行为面试练习题：讲讲你的项目","keywords":"","body":"2.7 行为面试练习题：讲讲你的项目 略 "},"chapter3/readme.html":{"url":"chapter3/readme.html","title":"第3章 Python语言基础考察点","keywords":"","body":"第3章 Python语言基础考察点 Python语言基础 "},"chapter3/3.1.html":{"url":"chapter3/3.1.html","title":"3.1 Python语言基础常考题","keywords":"","body":"3.1 Python语言基础常考题 Python是静态还是动态类型？是强类型还是弱类型？ 动态强类型语言（不少人误以为是弱类型） 动态还是静态指的是编译期还是运行期确定类型 强类型指的是不会发生隐式类型转换 Python作为后端语言优缺点 胶水语言，轮子多，应用广泛 语言灵活，生产力高 性能问题，代码维护问题，python2/3兼容问题 什么是鸭子类型 当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子 **关注点在对象的行为，而不是类型（duck typing）** 比如file，StringIO，socket对象都支持read/write方法（file like object） 再比如定义了__iter__魔法方法的对象都可以用for迭代 鸭子类型更关注接口而非类型 class Duck: def quack(self): print(\"gua gua\") class Person: def quack(self): print(\"我是人类，但我也会 gua gua gua\") def in_the_forest(duck): duck.quack() def game(): donald = Duck() john = Person() in_the_forest(donald) # gua gua in_the_forest(john) # 我是人类，但我也会 gua gua gua print(type(donald)) # print(type(john)) # print(isinstance(donald, Duck)) # True print(isinstance(john, Person)) # True game() 什么是monkey patch 什么是monkey patch 所谓的monkey patch就是运行时属性的替换 比如并发库gevent库需要修改内置的socket，从阻塞socket修改为非阻塞的socket from gevent import monkey;mokey.patch_socket() 哪些地方用到了？自己如何实现？ import socket print(socket.socket) # print(\"After monkey patch\") from gevent import monkey monkey.patch_socket() print(socket.socket) # import select print(select.select) # monkey.patch_select() print(\"After monkey patch\") print(select.select) # import time print(time.time()) # 1553175529.5860722 def _time(): return 1234 time.time = _time print(time.time()) # 1234 什么是自省：Introspection 运行时判断一个对象的类型的能力 Python一切皆对象，用type，id，isinstance获取对象类型信息 inspect模块提供了更多获取对象信息的函数 可以在运行时动态根据类型做出不同的行为 ll = [1, 2, 3] d = dict(a=1) # {a:1} print(type(ll)) # print(type(d)) # print(isinstance(ll, list)) # True print(isinstance(d, dict)) # True def add(a, b): if isinstance(a, int): return a + b elif isinstance(a, str): return a.upper() + b print(add(1, 2)) # 3 print(add('head', 'tail')) # HEADtail print(id(ll)) # 4547208 print(id(d)) # 33724528 print(ll is d) # False print(ll is ll) # True 什么是列表和字典推导 比如[i for i in range(10) if i%2==0] 一种快速生成list、dict、set的方式，用来替代map、filter等 (i for i in range(10) if i%2==0)返回生成器，节省内存 a = ['a', 'b', 'c'] b = [1, 2, 3] # d = {'a': 1, 'b':2, 'c':3} d = {} for i in range(len(a)): d[a[i]] = b[i] print(d) d = {k: v for k, v in zip(a, b)} print(d) 知道Python之禅吗 import this "},"chapter3/3.2.html":{"url":"chapter3/3.2.html","title":"3.2 Python2和3差异常考题","keywords":"","body":"3.2 Python2和3差异常考题 Python3改进 print成为函数 编码问题：Python3不再有unicode对象，默认str就是unicode unicode给人看的，字节串给电脑看的 操作的时候用unicode，使用decoding，传输、存储用字节串encoding >>> s='中文' >>> type(s) >>> b = s.encode() >>> b b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' >>> type(b) >>> c = b.decode() >>> c '中文' >>> type(c) >>> 除法变化：Python3除号返回浮点数 类型注解，type hint，帮助IDE实现类型检查 def hello(name: str) -> str: return 'hello' + name hello('loowang') # hello(123)# IDE会提示错误 优化的super()方法方便直接调用父类函数 class Base(object): def hello(self): print('hello') class C(Base): def hello(self): # py2 return super(C, self).hello() c = C() c.hello() class C2(Base): def hello(self): # py3 return super().hello() c2 = C2() c2.hello() 高级解包操作a,b,*rest=range(10) Keyword only arguments:限定关键字参数，需要制定参数名传参 参数特别多时，限定后面的参数必须给参数名，这样就不容易搞混 def add(a, b, *, c): return a + b + c print(add(1, 2, c=3)) # c必须给定参数名 Chained exceptions：Python3重新抛出异常不会丢失栈信息 raise from保留异常栈信息 方便排错 import shutil def mycopy(source, dest): try: shutil.copy2(source, dest) except OSError: # python2 里 raise 会丢失原来的 traceback 信息 raise NotImplementedError(\"automatic sudo injection\") from OSError mycopy('old', 'new') 一切返回迭代器range、zip、map、dict.values等都是返回迭代器，节省内存 Python3新增 yield from链接子生成器 asyncio内置库，async/await原生协程支持异步编程 新的内置库enum，mock，asyncio、ipaddress，concurrent.futures等 Python3改进 生成的pyc文件统一放到__pycache__ 一些内置库的修改，urllib，selector等 性能优化等 熟悉一些兼容2/3的工具 six模块（2*3=6） 2to3等工具转换代码 __future__ "},"chapter3/3.3.html":{"url":"chapter3/3.3.html","title":"3.3 Python函数常考题","keywords":"","body":"3.3 Python函数常考题 常考点 参数传递 (不)可变对象 可变参数 示例1：可变类型、不可变类型作为参数 def flist(l): l.append(0) print(id(l)) # 30368392，30368392 print(l) # [0]，[0, 0] ll = [] print(id(ll)) # 30368392 flist(ll) flist(ll) print('++++++++++++++++++++') def fstr(s): s += 'a' print(id(s)) # 33923400，33923400 print(s) # hehea，hehea ss = 'hehe' print(id(ss)) # 33849952 fstr(ss) fstr(ss) Python如何传递参数 传递值还是引用呢？都不是，唯一支持的参数传递是共享传参 Call by Object(Call by Object Reference or Call by Sharing)形参和实参指向同一个对象 Call by sharing(共享传参）。函数形参获得实参中各个引用的副本 Python可变/不可变对象 搞懂可变和不可变内置对象有利于理解函数参数的副作用 哪些是可变对象，哪些是不可变？ 不可变对象：bool/int/float/tuple/str/frozenset 可变对象：list/set/dict 测试题 # 一个小例题 def clear_list(l): l = [] ll = [1, 2, 3] clear_list(ll) print(ll) # [1, 2, 3] Python可变参数作为默认参数 默认参数只计算一次 def flist(l=[1]): l.append(1) print(l) flist() # [1, 1] flist() # [1, 1, 1] Python中的*args,**kwargs 用来处理可变参数 *args被打包成tuple **kwargs被打包成dict def print_multiple_args(*args): print(type(args), args) for idx, val in enumerate(args): print(idx, val) print_multiple_args(*['a', 'b', 'c']) \"\"\" ('a', 'b', 'c') 0 a 1 b 2 c \"\"\" def print_kwargs(**kwargs): print(type(kwargs), kwargs) for k, v in kwargs.items(): print('{}: {}'.format(k, v)) print_kwargs(**dict(a=1, b=2)) \"\"\" {'a': 1, 'b': 2} a: 1 b: 2 \"\"\" def print_all(a, *args, **kwargs): print(a) if args: print(args) if kwargs: print(kwargs) print_all('hello', 'world', name='muke') \"\"\" hello ('world',) {'name': 'muke'} \"\"\" "},"chapter3/3.4.html":{"url":"chapter3/3.4.html","title":"3.4 Python异常机制常考题","keywords":"","body":"3.4 Python异常机制常考题 BaseException SystemExit Keyboardinterrupt Exception StopIeration AttributeError ... 使用异常的常见场景 网络请求（超时、连接错误等） 资源访问（权限问题、资源不存在） 代码逻辑（越界访问、KeyError等） 自定义异常 继承Exception实现自定义异常，如果BaseException，用ctrl+c无法结束进程 给异常加上一些附加信息 处理一些业务相关的特定异常（raise MyException） class MyException(Exception): pass try: raise MyException('my exception') except Exception as e: print(e) "},"chapter3/3.5.html":{"url":"chapter3/3.5.html","title":"3.5 Python性能剖析与优化GIL常考题","keywords":"","body":"3.5 Python性能剖析与优化GIL常考题 GIL:Global Interpreter Lock CPython解释器的内存管理并不是线程安全的，多线程如果同时修改一个对象可能导致问题 保护多线程情况下对Python对象的访问 CPython使用简单的锁机制避免多个线程同时执行字节码 GIL的影响限制了线程的多核执行 同一时间只能有一个线程执行字节码 CPU密集程序难以利用多核优势 IO期间会释放GIL，对IO密集程序影响不大 如何规避GIL影响： 区分CPU和IO密集程序 CPU密集可以使用多进程+进程池 IO密集使用多线程/协程 cpython扩展 GIL实现 每隔一段时间释放当前的锁，让其它线程去获取锁 练习 import threading n = [0] def foo(): n[0] = n[0] + 1 n[0] = n[0] + 1 threads = [] for i in range(5000): t = threading.Thread(target=foo) threads.append(t) for t in threads: t.start() print(n) 执行结果不定 为什么有了GIL还要关注线程安全 Python中什么操作才是原子的？一步到位执行完 一个操作如果是一个字节码指定可以完成就是原子的 原子的是可以保证线程安全的 使用dis操作来分析字节码 原子操作是线程安全的 import dis def update_list(l): l[0] = 1 # 原子操作，不用担心线程安全问题 print(dis.dis(update_list)) \"\"\" 5 0 LOAD_CONST 1 (1) 2 LOAD_FAST 0 (l) 4 LOAD_CONST 2 (0) 6 STORE_SUBSCR # 单字节码操作，线程安全 8 LOAD_CONST 0 (None) 10 RETURN_VALUE \"\"\" 非原子操作不是线程安全的 import dis def incr_list(l): l[0] += 1 # 危险！！不是原子操作 print(dis.dis(incr_list)) \"\"\" 5 0 LOAD_FAST 0 (l) 2 LOAD_CONST 1 (0) 4 DUP_TOP_TWO 6 BINARY_SUBSCR 8 LOAD_CONST 2 (1) 10 INPLACE_ADD # 需要多个字节码操作 12 ROT_THREE # 有可能在线程执行过程中切换到其它线程 14 STORE_SUBSCR 16 LOAD_CONST 0 (None) 18 RETURN_VALUE \"\"\" 如何保证线程安全 加锁 import threading lock = threading.Lock() n = [0] def foo(): with lock: n[0] = n[0] + 1 n[0] = n[0] + 1 threads = [] for i in range(5000): t = threading.Thread(target=foo) threads.append(t) for t in threads: t.start() print(n) 如何剖析程序性能 使用各种profile工具（内置或第三方） 二八定律，大部分时间消耗在少量代码上 内置的profile/cprofile等工具 使用pyflame（uber开源）的火焰图工具 服务端性能优化措施 Web应用一般语言不会成为瓶颈 数据结构与算法优化 数据库层：索引优化、慢查询消除，批量操作减少多次IO，引入NoSQL提高性能 网络IO：批量操作，pipeline操作减少IO请求次数 缓存：使用内存数据库redis、memcached 异步：asyncio、celery 并发：gevent、多线程 "},"chapter3/3.6.html":{"url":"chapter3/3.6.html","title":"3.6 Python生成器与协程","keywords":"","body":"3.6 Python生成器与协程 生成器：Generator 生成器就是可以生成值的函数 当一个函数里有了yield关键字就成了生成器 生成器可以挂起执行并且保持当前执行的状态 def simple_gen(): yield 'hello' yield 'world' gen = simple_gen() print(type(gen)) # print(next(gen)) # hello print(next(gen)) # world 基于生成器的协程 Python3之前没有原生协程，只有基于生成器的协程 pep 342（Coroutines via enhanced generators）增强生成器功能 生成器可以通过yield暂停执行和产出数据 同时支持send()向生成器发送数据和throw()向生成器抛异常 Geerator based coroutine示例 def coro(): # yield关键字在=右边作为表达式，可以被send值 hello = yield 'hello' yield hello c = coro() # 这里调用next产出第一个值‘hello’，之后函数暂停 print(next(c)) # hello # 再次调用send发送值，此时hello变量赋值为‘world’，然后yield产出hello变量的值‘world’ print(c.send('world')) # world # 之后协程结束，后续再send值会抛异常StopIteration 协程注意点 协程需要使用send(None)或者next(coroutine)来“预激”(prime)才能启动 在yield处协程会暂停执行 单独的yield value会产出值给调用方 可以通过coroutine.send(value)来给协程发送值，发送的值会赋值给yield表达式左边的变量value=yield 协程执行完成后（没有遇到下一个yield语句）会抛出StopIteration异常 协程装饰器：避免每次都要用send预激它 from functools import wraps def coroutine(func): # 这样就不用每次都调用send(None)启动了 \"\"\"装饰器：向前执行到到第一个yield表达式，预激func \"\"\" @wraps(func) def primer(*args, **kwargs): gen = func(*args, **kwargs) next(gen) return gen return primer Python3.5引入async/await支持原生协程（native coroutine） import asyncio import datetime import random async def display_date(num, loop): end_time = loop.time() + 50.0 while True: print('Loop:{} Time:{}'.format(num, datetime.datetime.now())) if (loop.time() + 1.0) >= end_time: break await asyncio.sleep(random.randint(0, 5)) loop = asyncio.get_event_loop() asyncio.ensure_future(display_date(1, loop)) asyncio.ensure_future(display_date(2, loop)) loop.run_forever() "},"chapter3/3.7.html":{"url":"chapter3/3.7.html","title":"3.7 Python单元测试","keywords":"","body":"3.7 Python单元测试 什么是单元测试Unit Testing 针对程序模块进行正确性检验 一个函数、一个类进行验证 自底向上保证程序正确性 为什么要写单元测试 保证代码逻辑的正确性（甚至有些采用测试驱动开发TDD) 单测影响设计，易测的代码往往是高内聚低耦合的 回归测试，防止改一处整个服务不可用 单元测试相关库 nose、pytest较为常用 mock模块用来模拟替换网络请求 coverage统计测试覆盖率 "},"chapter3/3.8.html":{"url":"chapter3/3.8.html","title":"3.8 Python基础练习题深拷贝和浅拷贝","keywords":"","body":"3.8 Python基础练习题深拷贝和浅拷贝 略 "},"chapter4/readme.html":{"url":"chapter4/readme.html","title":"第4章 Python算法与数据结构考察点","keywords":"","body":"第4章 Python算法与数据结构考察点 Python算法与数据结构 "},"chapter4/1.html":{"url":"chapter4/1.html","title":"4.1 Python常见内置算法与数据结构常考题","keywords":"","body":"4.1 Python常见内置算法与数据结构常考题 常用内置数据结构和算法 数据结构/算法 语言内置 内置库 线性结构 list、tuple array，collocations，namedtuple 链式结构 - collocations.deque 字典结构 dict - 集合结构 set、frozenset - 排序算法 sorted - 二分算法 - biset模块 堆算法 - heapq模块 缓存算法 - functools.lru_cache(last recent used, python3) collections模块提供了一些内置数据结构的扩展 名称 解释 namedtuple() factory function for creating tuple subclasses with named fields deque list-like container with fast appends and pops on either end Counter dict subclass for counting hashable objects OrderedDict dict subclass that remenbers the order entries were added defaultdict dict subclass that calls a factory function to supply missing values namedtuple() 通过下标可读性不好 通过属性可读性比较好,namedtuple()让tuple属性可读>>> import collections >>> Point = collections.namedtuple('Point','x,y') >>> p = Point(1,2) >>> p.x 1 >>> p.y 2 >>> p[0] 1 >>> p[1] 2 >>> deque 双端队列，从左右两端append或pop很快>>> import collections >>> de = collections.deque() >>> de.append(1) >>> de.appendleft(0) >>> de deque([0, 1]) >>> de.pop() 1 >>> de.popleft() 0 >>> de deque([]) >>> Counter 实现计数功能，是个字典 可以求出最大的几个>>> import collections >>> c = collections.Counter('abcab') >>> c Counter({'a': 2, 'b': 2, 'c': 1}) >>> c['a'] 2 >>> c.most_common(2) [('a', 2), ('b', 2)] >>> OrederDict 记住了key插入的顺序 可以用来实现LRUcache>>> import collections >>> od = collections.OrderedDict() >>> od['c']='c' >>> od['b']='b' >>> od['a']='a' >>> list(od.keys()) ['c', 'b', 'a'] >>> defaultdict 带有默认值的字典 可以用来实现计数器>>> import collections >>> dd=collections.defaultdict(int) >>> dd['a'] 0 >>> dd['b']+=1 >>> dd defaultdict(, {'a': 0, 'b': 1}) >>> "},"chapter4/2.html":{"url":"chapter4/2.html","title":"4.2 Python面试常考算法","keywords":"","body":"4.2 Python面试常考算法 dict等层使用的哈希表 为了支持快速查找使用了哈希表作为底层结构 哈希表平均查找时间复杂度O(1) CPython解释器使用二次探查解决哈希冲突问题 哈希冲突和扩容是考察重点 list和tuple的区别 都是线性结构，支持下标访问 list是可变对象，tuple保存的引用不可变 保存的引用不可变指的是你没法替换掉这个对象 但是如果对那个本身是一个可变对象，是可以修改这个引用指向的可变对象的 list没法作为字典的key，tuple可以（可变对象不可hash） 什么是LRUCache? Least Recently Used替换掉最近最少使用的对象 为什么需要LRUCache 缓存剔除策略，当缓存空间不够用的时候需要一种方式剔除key 常用的有LRU等 LRU通过使用一个循环双端队列不断把最新访问的key放到表头实现，将表尾巴的剔除即可 如何实现LRUCache 字典用来缓存，循环双端链表用来记录访问顺序 利用Python内置的dict+collections.OrderedDict实现 dict用来当做key/value键值对的缓存 OrderedDict用来实现更新最近访问的key from collections import OrderedDict class LRUCache: def __init__(self, capacity=3): self.od = OrderedDict() self.capacity = capacity def get(self, key): # 每次访问更新最新使用的 key if key in self.od: val = self.od[key] self.od.move_to_end(key) # OrderedDict的方法 return val else: return -1 def put(self, key, value): # 更新 k/v if key in self.od: del self.od[key] self.od[key] = value # 更新 key 到表头 else: # insert self.od[key] = value # 判断当前容量是否已经满了 if len(self.od) > self.capacity: self.od.popitem(last=False) "},"chapter4/3.html":{"url":"chapter4/3.html","title":"4.3 Python数据结构常考题","keywords":"","body":"4.3 Python数据结构常考题 排序+查找，重中之重 常考排序算法：冒泡排序、快速排序、归并排序、堆排序 线性查找：二分查找等 能独立实现代码（手写），能够分析时间空间复杂度 常用排序算法的时间空间复杂度 排序算法 最差时间分析 平均时间复杂度 稳定度 空间复杂度 冒泡排序 O(n^2) O(n^2) 稳定 O(1) 选择排序 O(n^2) O(n^2) 不稳定 O(1) 插入排序 O(n^2) O(n^2) 稳定 O(1) 快速排序 O(n^2) O(nlog2n) 不稳定 O(log2n)-O(n) 堆排序 O(n*log2n) O(nlog2n) 不稳定 O(1) 稳定性 相同大小的元素在排序之后依然保持相对位置不变，就是稳定的 r[i]=r[j]且r[i]在r[j]之前，排序之后r[i]依然在r[j]之前 稳定性对于排序一个复杂结构，并且需要保持原有排序才有意义 快排 分治法divide and conquer，快排三步走 Partitiion：选择基准分割数组为两个子数组，小于基准和大于基准的 对两个子数组分别快排 合并结果 代码def quick_sort(array): # 递归出口 if len(array) pivot] return quick_sort(less_part) + [pivot] + quick_sort(great_part) 合并两个有序数组，要求a[n]，b[m]，O(n+m) ```python def merge_sorted_list(sorted_a, sorted_b): length_a, length_b = len(sorted_a), len(sorted_b) a = b = 0 # 两个指针，从索引0开始 new_sorted_seq = [] while a a = [1, 2, 5] b = [0, 3, 4, 8] print(merge_sorted_list(a, b)) # [0, 1, 2, 3, 4, 5, 8] ``` 归并排序 def merge_sorted_list(sorted_a, sorted_b): length_a, length_b = len(sorted_a), len(sorted_b) a = b = 0 new_sorted_seq = [] while a 实现堆排序 from heapq import heappop, heappush def heap_sort_use_heapq(itrable): items = [] for value in itrable: heappush(items, value) return [heappop(items) for i in range(len(items))] 二分查找 def binary_search(array, target): # 二分查找 if not array: return -1 beg, end = 0, len(array) while beg target: end = mid else: beg = mid + 1 return -1 def test(): \"\"\" 如何设计测试用例：(等价类划分) - 正常值功能测试 - 边界值（比如最大最小，最左最右值） - 异常值（比如 None，空值，非法值） \"\"\" # 正常值，包含有和无两种结果 assert binary_search([0, 1, 2, 3, 4, 5], 1) == 1 assert binary_search([0, 1, 2, 3, 4, 5], 6) == -1 assert binary_search([0, 1, 2, 3, 4, 5], -1) == -1 # 边界值 assert binary_search([0, 1, 2, 3, 4, 5], 0) == 0 assert binary_search([0, 1, 2, 3, 4, 5], 5) == 5 assert binary_search([0], 0) == 0 # 异常值 assert binary_search([], 1) == -1 "},"chapter4/4.html":{"url":"chapter4/4.html","title":"4.4 Python白板编程","keywords":"","body":"4.4 Python白板编程 常见类型 常见的数据结构：链表、队列、栈、二叉树、堆 使用内置结构实现高级数据结构，比如内置的list、deque实现栈 Leetcode或者>上的常见题 链表有单链表、双链表、循环双端列表 如何使用Python来表示链表结构 实现链表常见操作，比如插入节点，反转链表，合并多个链表等 Leetcode练习常见链表题目 反转单链表 # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def reverseList(self, head: ListNode) -> ListNode: pre = None cur = head while cur: nextnode = cur.next cur.next = pre pre = cur cur = nextnode return pre "},"chapter4/5.html":{"url":"chapter4/5.html","title":"4.5 Python数据结构常考题之链表","keywords":"","body":"4.5 Python数据结构常考题之链表 "},"chapter4/6.html":{"url":"chapter4/6.html","title":"4.6 Python数据结构常考题之二叉树","keywords":"","body":"4.6 Python数据结构常考题之二叉树 "},"chapter4/7.html":{"url":"chapter4/7.html","title":"4.7 Python数据结构常考题之栈与队列","keywords":"","body":"4.7 Python数据结构常考题之栈与队列 "},"chapter4/8.html":{"url":"chapter4/8.html","title":"4.8 Python数据结构常考题之堆","keywords":"","body":"4.8 Python数据结构常考题之堆 "},"chapter4/9.html":{"url":"chapter4/9.html","title":"4.9 Python字符串常考题算法题","keywords":"","body":"4.9 Python字符串常考题算法题 "},"chapter4/10.html":{"url":"chapter4/10.html","title":"4.10 算法与数据结构练习题反转链表","keywords":"","body":"4.10 算法与数据结构练习题反转链表 "},"chapter5/readme.html":{"url":"chapter5/readme.html","title":"第5章 编程范式考察点","keywords":"","body":"第5章 编程范式考察点 "},"chapter5/1.html":{"url":"chapter5/1.html","title":"5.1 面向对象基础及Python类常考题","keywords":"","body":"5.1 面向对象基础及Python类常考题 "},"chapter5/2.html":{"url":"chapter5/2.html","title":"5.2 装饰器面试常考题","keywords":"","body":"5.2 装饰器面试常考题 "},"chapter5/3.html":{"url":"chapter5/3.html","title":"5.3 设计模式：创建型模式","keywords":"","body":"5.3 设计模式：创建型模式 "},"chapter5/4.html":{"url":"chapter5/4.html","title":"5.4 设计模式：结构型模式","keywords":"","body":"5.4 设计模式：结构型模式 "},"chapter5/5.html":{"url":"chapter5/5.html","title":"5.5 设计模式：行为型模式","keywords":"","body":"5.5 设计模式：行为型模式 "},"chapter5/6.html":{"url":"chapter5/6.html","title":"5.6 Python函数式编程常考题","keywords":"","body":"5.6 Python函数式编程常考题 "},"chapter5/7.html":{"url":"chapter5/7.html","title":"5.7 编程范式练习题：编写一个单例模式","keywords":"","body":"5.7 编程范式练习题：编写一个单例模式 "},"chapter6/readme.html":{"url":"chapter6/readme.html","title":"第6章 操作系统考察点","keywords":"","body":"第6章 操作系统考察点 "},"chapter6/1.html":{"url":"chapter6/1.html","title":"6.1 面试常考Linux命令","keywords":"","body":"6.1 面试常考Linux命令 "},"chapter6/2.html":{"url":"chapter6/2.html","title":"6.2 操作系统线程和进程常考面试题","keywords":"","body":"6.2 操作系统线程和进程常考面试题 "},"chapter6/3.html":{"url":"chapter6/3.html","title":"6.3 操作系统内存管理机制与Python垃圾回收","keywords":"","body":"6.3 操作系统内存管理机制与Python垃圾回收 "},"chapter6/4.html":{"url":"chapter6/4.html","title":"6.4 线程练习题：多线程爬虫","keywords":"","body":"6.4 线程练习题：多线程爬虫 "},"chapter7/readme.html":{"url":"chapter7/readme.html","title":"第7章 网络编程考察点","keywords":"","body":"第7章 网络编程考察点 "},"chapter7/1.html":{"url":"chapter7/1.html","title":"7.1 网络协议TCP和UDP面试常考题","keywords":"","body":"7.1 网络协议TCP和UDP面试常考题 "},"chapter7/2.html":{"url":"chapter7/2.html","title":"7.2 HTTP面试常考题","keywords":"","body":"7.2 HTTP面试常考题 "},"chapter7/3.html":{"url":"chapter7/3.html","title":"7.3 网络编程常考题","keywords":"","body":"7.3 网络编程常考题 "},"chapter7/4.html":{"url":"chapter7/4.html","title":"7.4 并发编程IO多路复用常见考题","keywords":"","body":"7.4 并发编程IO多路复用常见考题 "},"chapter7/5.html":{"url":"chapter7/5.html","title":"7.5 Python并发网络库常考题","keywords":"","body":"7.5 Python并发网络库常考题 "},"chapter7/6.html":{"url":"chapter7/6.html","title":"7.6 异步框架练习题：异步爬虫","keywords":"","body":"7.6 异步框架练习题：异步爬虫 "},"chapter8/readme.html":{"url":"chapter8/readme.html","title":"第8章 数据库考察点","keywords":"","body":"第8章 数据库考察点 "},"chapter8/1.html":{"url":"chapter8/1.html","title":"8.1 MySQL基础常考题","keywords":"","body":"8.1 MySQL基础常考题 "},"chapter8/2.html":{"url":"chapter8/2.html","title":"8.2 MySQL索引优化常考题","keywords":"","body":"8.2 MySQL索引优化常考题 "},"chapter8/3.html":{"url":"chapter8/3.html","title":"8.3 SQL语句编写常考题","keywords":"","body":"8.3 SQL语句编写常考题 "},"chapter8/4.html":{"url":"chapter8/4.html","title":"8.4 缓存机制及Redis常考面试题","keywords":"","body":"8.4 缓存机制及Redis常考面试题 "},"chapter8/5.html":{"url":"chapter8/5.html","title":"8.5 数据库练习题：MySQL索引与Redis","keywords":"","body":"8.5 数据库练习题：MySQL索引与Redis "},"chapter9/readme.html":{"url":"chapter9/readme.html","title":"第9章 Python Web框架考察点","keywords":"","body":"第9章 Python Web框架考察点 "},"chapter9/1.html":{"url":"chapter9/1.html","title":"9.1 Python WSGI与Web框架考点","keywords":"","body":"9.1 Python WSGI与Web框架考点 "},"chapter9/2.html":{"url":"chapter9/2.html","title":"9.2 Web安全考察点","keywords":"","body":"9.2 Web安全考察点 "},"chapter9/3.html":{"url":"chapter9/3.html","title":"9.3 前后端分离与RESTful常见面试题","keywords":"","body":"9.3 前后端分离与RESTful常见面试题 "},"chapter9/4.html":{"url":"chapter9/4.html","title":"9.4 Web安全思考题：什么是HTTPS","keywords":"","body":"9.4 Web安全思考题：什么是HTTPS "},"chapter10/readme.html":{"url":"chapter10/readme.html","title":"第10章 系统设计考察点","keywords":"","body":"第10章 系统设计考察点 "},"chapter10/1.html":{"url":"chapter10/1.html","title":"10.1 系统设计考点解析","keywords":"","body":"10.1 系统设计考点解析 "},"chapter10/2.html":{"url":"chapter10/2.html","title":"10.2 系统设计真题解析","keywords":"","body":"10.2 系统设计真题解析 "},"chapter10/3.html":{"url":"chapter10/3.html","title":"10.3 系统设计思考题","keywords":"","body":"10.3 系统设计思考题 "},"chapter11/readme.html":{"url":"chapter11/readme.html","title":"第11章 面试经验分享","keywords":"","body":"第11章 面试经验分享 "},"chapter11/1.html":{"url":"chapter11/1.html","title":"11.1 面试经验分享","keywords":"","body":"11.1 面试经验分享 "},"chapter12/readme.html":{"url":"chapter12/readme.html","title":"第12章 课程总结","keywords":"","body":"第12章 课程总结 "},"chapter12/1.html":{"url":"chapter12/1.html","title":"12.1 课程总结","keywords":"","body":"12.1 课程总结 "}}