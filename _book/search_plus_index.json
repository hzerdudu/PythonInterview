{"./":{"url":"./","title":"简介","keywords":"","body":"简介 Python面试 "},"chapter1/readme.html":{"url":"chapter1/readme.html","title":"第1章 课程导学","keywords":"","body":"第1章 课程导学 课程导学 "},"chapter1/1.1.html":{"url":"chapter1/1.1.html","title":"1.1 Python服务端工程师面试指导","keywords":"","body":"1.1 Python服务端工程师面试指导 面试技巧篇 Python语言篇 算法与数据结构篇 编程范式篇 操作系统篇 网络编程篇 数据库篇 Web框架篇 系统设计篇 面试经验篇 "},"chapter2/readme.html":{"url":"chapter2/readme.html","title":"第2章 面试流程介绍","keywords":"","body":"第2章 面试流程介绍 面试流程介绍 "},"chapter2/2.1.html":{"url":"chapter2/2.1.html","title":"2.1 Python后端职位分析","keywords":"","body":"2.1 Python后端职位分析 略 "},"chapter2/2.2.html":{"url":"chapter2/2.2.html","title":"2.2 面试流程和环节","keywords":"","body":"2.2 面试流程和环节 学生重基础，社招重项目 一面问基础 二面问项目 三面问设计 "},"chapter2/2.3.html":{"url":"chapter2/2.3.html","title":"2.3 Python后端技术栈","keywords":"","body":"2.3 Python后端技术栈 略 "},"chapter2/2.4.html":{"url":"chapter2/2.4.html","title":"2.4 Python初中级工程师技能要求","keywords":"","body":"2.4 Python初中级工程师技能要求 略 "},"chapter2/2.5.html":{"url":"chapter2/2.5.html","title":"2.5 简历书写与自我介绍","keywords":"","body":"2.5 简历书写与自我介绍 略 "},"chapter2/2.6.html":{"url":"chapter2/2.6.html","title":"2.6 行为面试常见问题与回答技巧","keywords":"","body":"2.6 行为面试常见问题与回答技巧 START模型 情境：什么情况下发生的 任务：你是如何明确你的任务的 行动：采取了什么样的行动 结果：结果是怎么样的？学到了什么？ 你还有什么要问我的吗？ 表现出兴趣：问问工作内容（业务）、技术栈、团队、项目等 问自己的感兴趣的问题，比如架构问题 "},"chapter2/2.7.html":{"url":"chapter2/2.7.html","title":"2.7 行为面试练习题：讲讲你的项目","keywords":"","body":"2.7 行为面试练习题：讲讲你的项目 略 "},"chapter3/readme.html":{"url":"chapter3/readme.html","title":"第3章 Python语言基础考察点","keywords":"","body":"第3章 Python语言基础考察点 Python语言基础 "},"chapter3/3.1.html":{"url":"chapter3/3.1.html","title":"3.1 Python语言基础常考题","keywords":"","body":"3.1 Python语言基础常考题 Python是静态还是动态类型？是强类型还是弱类型？ 动态强类型语言（不少人误以为是弱类型） 动态还是静态指的是编译期还是运行期确定类型 强类型指的是不会发生隐式类型转换 Python作为后端语言优缺点 胶水语言，轮子多，应用广泛 语言灵活，生产力高 性能问题，代码维护问题，python2/3兼容问题 什么是鸭子类型 当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子 **关注点在对象的行为，而不是类型（duck typing）** 比如file，StringIO，socket对象都支持read/write方法（file like object） 再比如定义了__iter__魔法方法的对象都可以用for迭代 鸭子类型更关注接口而非类型 class Duck: def quack(self): print(\"gua gua\") class Person: def quack(self): print(\"我是人类，但我也会 gua gua gua\") def in_the_forest(duck): duck.quack() def game(): donald = Duck() john = Person() in_the_forest(donald) # gua gua in_the_forest(john) # 我是人类，但我也会 gua gua gua print(type(donald)) # print(type(john)) # print(isinstance(donald, Duck)) # True print(isinstance(john, Person)) # True game() 什么是monkey patch 什么是monkey patch 所谓的monkey patch就是运行时属性的替换 比如并发库gevent库需要修改内置的socket，从阻塞socket修改为非阻塞的socket from gevent import monkey;mokey.patch_socket() 哪些地方用到了？自己如何实现？ import socket print(socket.socket) # print(\"After monkey patch\") from gevent import monkey monkey.patch_socket() print(socket.socket) # import select print(select.select) # monkey.patch_select() print(\"After monkey patch\") print(select.select) # import time print(time.time()) # 1553175529.5860722 def _time(): return 1234 time.time = _time print(time.time()) # 1234 什么是自省：Introspection 运行时判断一个对象的类型的能力 Python一切皆对象，用type，id，isinstance获取对象类型信息 inspect模块提供了更多获取对象信息的函数 可以在运行时动态根据类型做出不同的行为 ll = [1, 2, 3] d = dict(a=1) # {a:1} print(type(ll)) # print(type(d)) # print(isinstance(ll, list)) # True print(isinstance(d, dict)) # True def add(a, b): if isinstance(a, int): return a + b elif isinstance(a, str): return a.upper() + b print(add(1, 2)) # 3 print(add('head', 'tail')) # HEADtail print(id(ll)) # 4547208 print(id(d)) # 33724528 print(ll is d) # False print(ll is ll) # True 什么是列表和字典推导 比如[i for i in range(10) if i%2==0] 一种快速生成list、dict、set的方式，用来替代map、filter等 (i for i in range(10) if i%2==0)返回生成器，节省内存 a = ['a', 'b', 'c'] b = [1, 2, 3] # d = {'a': 1, 'b':2, 'c':3} d = {} for i in range(len(a)): d[a[i]] = b[i] print(d) d = {k: v for k, v in zip(a, b)} print(d) 知道Python之禅吗 import this "},"chapter3/3.2.html":{"url":"chapter3/3.2.html","title":"3.2 Python2和3差异常考题","keywords":"","body":"3.2 Python2和3差异常考题 Python3改进 print成为函数 编码问题：Python3不再有unicode对象，默认str就是unicode unicode给人看的，字节串给电脑看的 操作的时候用unicode，使用decoding，传输、存储用字节串encoding >>> s='中文' >>> type(s) >>> b = s.encode() >>> b b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' >>> type(b) >>> c = b.decode() >>> c '中文' >>> type(c) >>> 除法变化：Python3除号返回浮点数 类型注解，type hint，帮助IDE实现类型检查 def hello(name: str) -> str: return 'hello' + name hello('loowang') # hello(123)# IDE会提示错误 优化的super()方法方便直接调用父类函数 class Base(object): def hello(self): print('hello') class C(Base): def hello(self): # py2 return super(C, self).hello() c = C() c.hello() class C2(Base): def hello(self): # py3 return super().hello() c2 = C2() c2.hello() 高级解包操作a,b,*rest=range(10) Keyword only arguments:限定关键字参数，需要制定参数名传参 参数特别多时，限定后面的参数必须给参数名，这样就不容易搞混 def add(a, b, *, c): return a + b + c print(add(1, 2, c=3)) # c必须给定参数名 Chained exceptions：Python3重新抛出异常不会丢失栈信息 raise from保留异常栈信息 方便排错 import shutil def mycopy(source, dest): try: shutil.copy2(source, dest) except OSError: # python2 里 raise 会丢失原来的 traceback 信息 raise NotImplementedError(\"automatic sudo injection\") from OSError mycopy('old', 'new') 一切返回迭代器range、zip、map、dict.values等都是返回迭代器，节省内存 Python3新增 yield from链接子生成器 asyncio内置库，async/await原生协程支持异步编程 新的内置库enum，mock，asyncio、ipaddress，concurrent.futures等 Python3改进 生成的pyc文件统一放到__pycache__ 一些内置库的修改，urllib，selector等 性能优化等 熟悉一些兼容2/3的工具 six模块（2*3=6） 2to3等工具转换代码 __future__ "},"chapter3/3.3.html":{"url":"chapter3/3.3.html","title":"3.3 Python函数常考题","keywords":"","body":"3.3 Python函数常考题 常考点 参数传递 (不)可变对象 可变参数 示例1：可变类型、不可变类型作为参数 def flist(l): l.append(0) print(id(l)) # 30368392，30368392 print(l) # [0]，[0, 0] ll = [] print(id(ll)) # 30368392 flist(ll) flist(ll) print('++++++++++++++++++++') def fstr(s): s += 'a' print(id(s)) # 33923400，33923400 print(s) # hehea，hehea ss = 'hehe' print(id(ss)) # 33849952 fstr(ss) fstr(ss) Python如何传递参数 传递值还是引用呢？都不是，唯一支持的参数传递是共享传参 Call by Object(Call by Object Reference or Call by Sharing)形参和实参指向同一个对象 Call by sharing(共享传参）。函数形参获得实参中各个引用的副本 Python可变/不可变对象 搞懂可变和不可变内置对象有利于理解函数参数的副作用 哪些是可变对象，哪些是不可变？ 不可变对象：bool/int/float/tuple/str/frozenset 可变对象：list/set/dict 测试题 # 一个小例题 def clear_list(l): l = [] ll = [1, 2, 3] clear_list(ll) print(ll) # [1, 2, 3] Python可变参数作为默认参数 默认参数只计算一次 def flist(l=[1]): l.append(1) print(l) flist() # [1, 1] flist() # [1, 1, 1] Python中的*args,**kwargs 用来处理可变参数 *args被打包成tuple **kwargs被打包成dict def print_multiple_args(*args): print(type(args), args) for idx, val in enumerate(args): print(idx, val) print_multiple_args(*['a', 'b', 'c']) \"\"\" ('a', 'b', 'c') 0 a 1 b 2 c \"\"\" def print_kwargs(**kwargs): print(type(kwargs), kwargs) for k, v in kwargs.items(): print('{}: {}'.format(k, v)) print_kwargs(**dict(a=1, b=2)) \"\"\" {'a': 1, 'b': 2} a: 1 b: 2 \"\"\" def print_all(a, *args, **kwargs): print(a) if args: print(args) if kwargs: print(kwargs) print_all('hello', 'world', name='muke') \"\"\" hello ('world',) {'name': 'muke'} \"\"\" "},"chapter3/3.4.html":{"url":"chapter3/3.4.html","title":"3.4 Python异常机制常考题","keywords":"","body":"3.4 Python异常机制常考题 BaseException SystemExit Keyboardinterrupt Exception StopIeration AttributeError ... 使用异常的常见场景 网络请求（超时、连接错误等） 资源访问（权限问题、资源不存在） 代码逻辑（越界访问、KeyError等） 自定义异常 继承Exception实现自定义异常，如果BaseException，用ctrl+c无法结束进程 给异常加上一些附加信息 处理一些业务相关的特定异常（raise MyException） class MyException(Exception): pass try: raise MyException('my exception') except Exception as e: print(e) "},"chapter3/3.5.html":{"url":"chapter3/3.5.html","title":"3.5 Python性能剖析与优化GIL常考题","keywords":"","body":"3.5 Python性能剖析与优化GIL常考题 GIL:Global Interpreter Lock CPython解释器的内存管理并不是线程安全的，多线程如果同时修改一个对象可能导致问题 保护多线程情况下对Python对象的访问 CPython使用简单的锁机制避免多个线程同时执行字节码 GIL的影响限制了线程的多核执行 同一时间只能有一个线程执行字节码 CPU密集程序难以利用多核优势 IO期间会释放GIL，对IO密集程序影响不大 如何规避GIL影响： 区分CPU和IO密集程序 CPU密集可以使用多进程+进程池 IO密集使用多线程/协程 cpython扩展 GIL实现 每隔一段时间释放当前的锁，让其它线程去获取锁 练习 import threading n = [0] def foo(): n[0] = n[0] + 1 n[0] = n[0] + 1 threads = [] for i in range(5000): t = threading.Thread(target=foo) threads.append(t) for t in threads: t.start() print(n) 执行结果不定 为什么有了GIL还要关注线程安全 Python中什么操作才是原子的？一步到位执行完 一个操作如果是一个字节码指定可以完成就是原子的 原子的是可以保证线程安全的 使用dis操作来分析字节码 原子操作是线程安全的 import dis def update_list(l): l[0] = 1 # 原子操作，不用担心线程安全问题 print(dis.dis(update_list)) \"\"\" 5 0 LOAD_CONST 1 (1) 2 LOAD_FAST 0 (l) 4 LOAD_CONST 2 (0) 6 STORE_SUBSCR # 单字节码操作，线程安全 8 LOAD_CONST 0 (None) 10 RETURN_VALUE \"\"\" 非原子操作不是线程安全的 import dis def incr_list(l): l[0] += 1 # 危险！！不是原子操作 print(dis.dis(incr_list)) \"\"\" 5 0 LOAD_FAST 0 (l) 2 LOAD_CONST 1 (0) 4 DUP_TOP_TWO 6 BINARY_SUBSCR 8 LOAD_CONST 2 (1) 10 INPLACE_ADD # 需要多个字节码操作 12 ROT_THREE # 有可能在线程执行过程中切换到其它线程 14 STORE_SUBSCR 16 LOAD_CONST 0 (None) 18 RETURN_VALUE \"\"\" 如何保证线程安全 加锁 import threading lock = threading.Lock() n = [0] def foo(): with lock: n[0] = n[0] + 1 n[0] = n[0] + 1 threads = [] for i in range(5000): t = threading.Thread(target=foo) threads.append(t) for t in threads: t.start() print(n) 如何剖析程序性能 使用各种profile工具（内置或第三方） 二八定律，大部分时间消耗在少量代码上 内置的profile/cprofile等工具 使用pyflame（uber开源）的火焰图工具 服务端性能优化措施 Web应用一般语言不会成为瓶颈 数据结构与算法优化 数据库层：索引优化、慢查询消除，批量操作减少多次IO，引入NoSQL提高性能 网络IO：批量操作，pipeline操作减少IO请求次数 缓存：使用内存数据库redis、memcached 异步：asyncio、celery 并发：gevent、多线程 "},"chapter3/3.6.html":{"url":"chapter3/3.6.html","title":"3.6 Python生成器与协程","keywords":"","body":"3.6 Python生成器与协程 生成器：Generator 生成器就是可以生成值的函数 当一个函数里有了yield关键字就成了生成器 生成器可以挂起执行并且保持当前执行的状态 def simple_gen(): yield 'hello' yield 'world' gen = simple_gen() print(type(gen)) # print(next(gen)) # hello print(next(gen)) # world 基于生成器的协程 Python3之前没有原生协程，只有基于生成器的协程 pep 342（Coroutines via enhanced generators）增强生成器功能 生成器可以通过yield暂停执行和产出数据 同时支持send()向生成器发送数据和throw()向生成器抛异常 Geerator based coroutine示例 def coro(): # yield关键字在=右边作为表达式，可以被send值 hello = yield 'hello' yield hello c = coro() # 这里调用next产出第一个值‘hello’，之后函数暂停 print(next(c)) # hello # 再次调用send发送值，此时hello变量赋值为‘world’，然后yield产出hello变量的值‘world’ print(c.send('world')) # world # 之后协程结束，后续再send值会抛异常StopIteration 协程注意点 协程需要使用send(None)或者next(coroutine)来“预激”(prime)才能启动 在yield处协程会暂停执行 单独的yield value会产出值给调用方 可以通过coroutine.send(value)来给协程发送值，发送的值会赋值给yield表达式左边的变量value=yield 协程执行完成后（没有遇到下一个yield语句）会抛出StopIteration异常 协程装饰器：避免每次都要用send预激它 from functools import wraps def coroutine(func): # 这样就不用每次都调用send(None)启动了 \"\"\"装饰器：向前执行到到第一个yield表达式，预激func \"\"\" @wraps(func) def primer(*args, **kwargs): gen = func(*args, **kwargs) next(gen) return gen return primer Python3.5引入async/await支持原生协程（native coroutine） import asyncio import datetime import random async def display_date(num, loop): end_time = loop.time() + 50.0 while True: print('Loop:{} Time:{}'.format(num, datetime.datetime.now())) if (loop.time() + 1.0) >= end_time: break await asyncio.sleep(random.randint(0, 5)) loop = asyncio.get_event_loop() asyncio.ensure_future(display_date(1, loop)) asyncio.ensure_future(display_date(2, loop)) loop.run_forever() "},"chapter3/3.7.html":{"url":"chapter3/3.7.html","title":"3.7 Python单元测试","keywords":"","body":"3.7 Python单元测试 什么是单元测试Unit Testing 针对程序模块进行正确性检验 一个函数、一个类进行验证 自底向上保证程序正确性 为什么要写单元测试 保证代码逻辑的正确性（甚至有些采用测试驱动开发TDD) 单测影响设计，易测的代码往往是高内聚低耦合的 回归测试，防止改一处整个服务不可用 单元测试相关库 nose、pytest较为常用 mock模块用来模拟替换网络请求 coverage统计测试覆盖率 "},"chapter3/3.8.html":{"url":"chapter3/3.8.html","title":"3.8 Python基础练习题深拷贝和浅拷贝","keywords":"","body":"3.8 Python基础练习题深拷贝和浅拷贝 略 "},"chapter4/readme.html":{"url":"chapter4/readme.html","title":"第4章 Python算法与数据结构考察点","keywords":"","body":"第4章 Python算法与数据结构考察点 Python算法与数据结构 "},"chapter4/1.html":{"url":"chapter4/1.html","title":"4.1 Python常见内置算法与数据结构常考题","keywords":"","body":"4.1 Python常见内置算法与数据结构常考题 常用内置数据结构和算法 数据结构/算法 语言内置 内置库 线性结构 list、tuple array，collocations，namedtuple 链式结构 - collocations.deque 字典结构 dict - 集合结构 set、frozenset - 排序算法 sorted - 二分算法 - biset模块 堆算法 - heapq模块 缓存算法 - functools.lru_cache(last recent used, python3) collections模块提供了一些内置数据结构的扩展 名称 解释 namedtuple() factory function for creating tuple subclasses with named fields deque list-like container with fast appends and pops on either end Counter dict subclass for counting hashable objects OrderedDict dict subclass that remenbers the order entries were added defaultdict dict subclass that calls a factory function to supply missing values namedtuple() 通过下标可读性不好 通过属性可读性比较好,namedtuple()让tuple属性可读>>> import collections >>> Point = collections.namedtuple('Point','x,y') >>> p = Point(1,2) >>> p.x 1 >>> p.y 2 >>> p[0] 1 >>> p[1] 2 >>> deque 双端队列，从左右两端append或pop很快>>> import collections >>> de = collections.deque() >>> de.append(1) >>> de.appendleft(0) >>> de deque([0, 1]) >>> de.pop() 1 >>> de.popleft() 0 >>> de deque([]) >>> Counter 实现计数功能，是个字典 可以求出最大的几个>>> import collections >>> c = collections.Counter('abcab') >>> c Counter({'a': 2, 'b': 2, 'c': 1}) >>> c['a'] 2 >>> c.most_common(2) [('a', 2), ('b', 2)] >>> OrederDict 记住了key插入的顺序 可以用来实现LRUcache>>> import collections >>> od = collections.OrderedDict() >>> od['c']='c' >>> od['b']='b' >>> od['a']='a' >>> list(od.keys()) ['c', 'b', 'a'] >>> defaultdict 带有默认值的字典 可以用来实现计数器>>> import collections >>> dd=collections.defaultdict(int) >>> dd['a'] 0 >>> dd['b']+=1 >>> dd defaultdict(, {'a': 0, 'b': 1}) >>> "},"chapter4/2.html":{"url":"chapter4/2.html","title":"4.2 Python面试常考算法","keywords":"","body":"4.2 Python面试常考算法 dict等层使用的哈希表 为了支持快速查找使用了哈希表作为底层结构 哈希表平均查找时间复杂度O(1) CPython解释器使用二次探查解决哈希冲突问题 哈希冲突和扩容是考察重点 list和tuple的区别 都是线性结构，支持下标访问 list是可变对象，tuple保存的引用不可变 保存的引用不可变指的是你没法替换掉这个对象 但是如果对那个本身是一个可变对象，是可以修改这个引用指向的可变对象的 list没法作为字典的key，tuple可以（可变对象不可hash） 什么是LRUCache? Least Recently Used替换掉最近最少使用的对象 为什么需要LRUCache 缓存剔除策略，当缓存空间不够用的时候需要一种方式剔除key 常用的有LRU等 LRU通过使用一个循环双端队列不断把最新访问的key放到表头实现，将表尾巴的剔除即可 如何实现LRUCache 字典用来缓存，循环双端链表用来记录访问顺序 利用Python内置的dict+collections.OrderedDict实现 dict用来当做key/value键值对的缓存 OrderedDict用来实现更新最近访问的key from collections import OrderedDict class LRUCache: def __init__(self, capacity=3): self.od = OrderedDict() self.capacity = capacity def get(self, key): # 每次访问更新最新使用的 key if key in self.od: val = self.od[key] self.od.move_to_end(key) # OrderedDict的方法 return val else: return -1 def put(self, key, value): # 更新 k/v if key in self.od: del self.od[key] self.od[key] = value # 更新 key 到表头 else: # insert self.od[key] = value # 判断当前容量是否已经满了 if len(self.od) > self.capacity: self.od.popitem(last=False) "},"chapter4/3.html":{"url":"chapter4/3.html","title":"4.3 Python数据结构常考题","keywords":"","body":"4.3 Python数据结构常考题 排序+查找，重中之重 常考排序算法：冒泡排序、快速排序、归并排序、堆排序 线性查找：二分查找等 能独立实现代码（手写），能够分析时间空间复杂度 常用排序算法的时间空间复杂度 排序算法 最差时间分析 平均时间复杂度 稳定度 空间复杂度 冒泡排序 O(n^2) O(n^2) 稳定 O(1) 选择排序 O(n^2) O(n^2) 不稳定 O(1) 插入排序 O(n^2) O(n^2) 稳定 O(1) 快速排序 O(n^2) O(nlog2n) 不稳定 O(log2n)-O(n) 堆排序 O(n*log2n) O(nlog2n) 不稳定 O(1) 稳定性 相同大小的元素在排序之后依然保持相对位置不变，就是稳定的 r[i]=r[j]且r[i]在r[j]之前，排序之后r[i]依然在r[j]之前 稳定性对于排序一个复杂结构，并且需要保持原有排序才有意义 快排 分治法divide and conquer，快排三步走 Partitiion：选择基准分割数组为两个子数组，小于基准和大于基准的 对两个子数组分别快排 合并结果 代码def quick_sort(array): # 递归出口 if len(array) pivot] return quick_sort(less_part) + [pivot] + quick_sort(great_part) 合并两个有序数组，要求a[n]，b[m]，O(n+m) ```python def merge_sorted_list(sorted_a, sorted_b): length_a, length_b = len(sorted_a), len(sorted_b) a = b = 0 # 两个指针，从索引0开始 new_sorted_seq = [] while a a = [1, 2, 5] b = [0, 3, 4, 8] print(merge_sorted_list(a, b)) # [0, 1, 2, 3, 4, 5, 8] ``` 归并排序 def merge_sorted_list(sorted_a, sorted_b): length_a, length_b = len(sorted_a), len(sorted_b) a = b = 0 new_sorted_seq = [] while a 实现堆排序 from heapq import heappop, heappush def heap_sort_use_heapq(itrable): items = [] for value in itrable: heappush(items, value) return [heappop(items) for i in range(len(items))] 二分查找 def binary_search(array, target): # 二分查找 if not array: return -1 beg, end = 0, len(array) while beg target: end = mid else: beg = mid + 1 return -1 def test(): \"\"\" 如何设计测试用例：(等价类划分) - 正常值功能测试 - 边界值（比如最大最小，最左最右值） - 异常值（比如 None，空值，非法值） \"\"\" # 正常值，包含有和无两种结果 assert binary_search([0, 1, 2, 3, 4, 5], 1) == 1 assert binary_search([0, 1, 2, 3, 4, 5], 6) == -1 assert binary_search([0, 1, 2, 3, 4, 5], -1) == -1 # 边界值 assert binary_search([0, 1, 2, 3, 4, 5], 0) == 0 assert binary_search([0, 1, 2, 3, 4, 5], 5) == 5 assert binary_search([0], 0) == 0 # 异常值 assert binary_search([], 1) == -1 "},"chapter4/4.html":{"url":"chapter4/4.html","title":"4.4 Python白板编程","keywords":"","body":"4.4 Python白板编程 常见类型 常见的数据结构：链表、队列、栈、二叉树、堆 使用内置结构实现高级数据结构，比如内置的list、deque实现栈 Leetcode或者>上的常见题 链表有单链表、双链表、循环双端列表 如何使用Python来表示链表结构 实现链表常见操作，比如插入节点，反转链表，合并多个链表等 Leetcode练习常见链表题目 反转单链表 # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def reverseList(self, head: ListNode) -> ListNode: pre = None cur = head while cur: nextnode = cur.next cur.next = pre pre = cur cur = nextnode return pre 队列 先进先出 使用双端队列实现 from collections import deque class Queue: def __init__(self): self.items = deque() def append(self, val): return self.items.append(val) def pop(self): return self.items.popleft() def empty(self): return len(self.items) == 0 栈 后进先出 使用双端队列实现 from collections import deque class Stack(object): def __init__(self): self.deque = deque() def push(self, value): self.deque.append(value) def pop(self): self.deque.pop() 如何使用两个栈实现队列 如何实现最小值栈，每次获取最小值 字典与集合 底层都是哈希表 哈希表的实现原理，底层其实就是一个数组 根据哈希函数快速定位一个元素，平均查找O(1),非常快 不断加入元素会引起哈希表重新开辟空间，拷贝之前元素得到新数组 哈希表如何解决冲突 链接法和开放寻址法 元素key冲突之后使用一个链表填充相同key的元素 开放寻址法是冲突之后根据一种方式（二次探查）寻找下一个可用的槽 cpython使用的是二次探查 二叉树 先序、中序、后序遍历 先序：先处理根，左子树，右子树 中序：先处理左子树、根、右子树 后序：先处理左子树、右子树、根 树的遍历方式 先序遍历，递归代码里处理根就好了 先序、中序遍历 class BinTreeNode(object): def __init__(self, data, left=None, right=None): self.data, self.left, self.right = data, left, right class BinTree(object): def __init__(self, root=None): self.root = root def pre_order(self, subtree): if subtree is not None: print(subtree.data) # 递归函数里先处理根 self.pre_order(subtree.left) # 递归处理左子树 self.pre_order(subtree.right) # 递归处理右子树 def in_order(self, subtree): if subtree is not None: self.in_order(subtree.left) print(subtree.data) self.in_order(subtree.right) 堆 堆其实是完全二叉树，有最大堆和最小堆 最大堆：对于每个非叶子节点v，v的值都比它的两个孩子大 最大堆支持每次pop操作获取最大的元素，最小堆获取最小元素 常见问题：用堆来完成topk问题，从海量数据中寻找最大的k个 import heapq class TopK: \"\"\"获取大量元素 topk 大个元素，固定内存 思路： 1. 先放入元素前 k 个建立一个最小堆 2. 迭代剩余元素： 如果当前元素小于堆顶元素，跳过该元素（肯定不是前 k 大） 否则替换堆顶元素为当前元素，并重新调整堆 \"\"\" def __init__(self, iterable, k): self.minheap = [] self.capacity = k self.iterable = iterable def push(self, val): if len(self.minheap) >= self.capacity: min_val = self.minheap[0] if val min_val操作，这里我只是显示指出跳过这个元素 pass else: heapq.heapreplace(self.minheap, val) # 返回并且pop堆顶最小值，推入新的 val 值并调整堆 else: heapq.heappush(self.minheap, val) # 前面 k 个元素直接放入minheap def get_topk(self): for val in self.iterable: self.push(val) return self.minheap def test(): import random i = list(range(1000)) # 这里可以是一个可迭代元素，节省内存 random.shuffle(i) print(i) _ = TopK(i, 10) print(_.get_topk()) # [990, 991, 992, 996, 994, 993, 997, 998, 999, 995] test() "},"chapter4/5.html":{"url":"chapter4/5.html","title":"4.5 Python数据结构常考题之链表","keywords":"","body":"4.5 Python数据结构常考题之链表 删除链表中的一个节点 # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def deleteNode(self, node): \"\"\" :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. \"\"\" nextnode = node.next after_nextnode = node.next.next node.val = nextnode.val node.next = after_nextnode 合并两个有序链表 # Definition for singly-linked list. class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode: root = ListNode(None) cur = root while l1 and l2: if l1.val "},"chapter4/6.html":{"url":"chapter4/6.html","title":"4.6 Python数据结构常考题之二叉树","keywords":"","body":"4.6 Python数据结构常考题之二叉树 二叉树设计到递归和指针操作 二叉树镜像，二叉树反转 原题：https://leetcode.com/problems/invert-binary-tree/ 代码 # Definition for a binary tree node. class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if root: root.left, root.right = root.right, root.left self.invertTree(root.left) self.invertTree(root.right) return root 二叉树层次遍历（广度优先） 代码 # Definition for a binary tree node. class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def levelOrder(self, root: TreeNode) -> List[List[int]]: if not root: return [] res = [] cur_nodes = [root] next_nodes = [] res.append([i.val for i in cur_nodes]) while cur_nodes or next_nodes: for node in cur_nodes: if node.left: next_nodes.append(node.left) if node.right: next_nodes.append(node.right) if next_nodes: res.append([i.val for i in next_nodes]) cur_nodes = next_nodes next_nodes = [] return res 求二叉树的左视图、右视图 "},"chapter4/7.html":{"url":"chapter4/7.html","title":"4.7 Python数据结构常考题之栈与队列","keywords":"","body":"4.7 Python数据结构常考题之栈与队列 用栈实现队列 栈：后进先出 队列：先进后出 使用两个栈，栈1，栈2，栈2不为空，直接pop 否则把栈1的所有元素放到栈2，然后执行栈2的pop操作 代码 from collections import deque class Stack: def __init__(self): self.items = deque() def push(self, val): return self.items.append(val) def pop(self): return self.items.pop() def empty(self): return len(self.items) == 0 def top(self): return self.items[-1] class MyQueue: def __init__(self): \"\"\" Initialize your data structure here. \"\"\" self.s1 = Stack() self.s2 = Stack() def push(self, x: int) -> None: \"\"\" Push element x to the back of queue. \"\"\" self.s1.push(x) def pop(self) -> int: \"\"\" Removes the element from in front of queue and returns that element. \"\"\" if not self.s2.empty(): return self.s2.pop() while not self.s1.empty(): val = self.s1.pop() self.s2.push(val) return self.s2.pop() def peek(self) -> int: \"\"\" Get the front element. \"\"\" if self.s2.empty(): return self.s2.top() while not self.s1.empty(): val = self.s1.pop() self.s2.push(val) return self.s2.top() def empty(self) -> bool: \"\"\" Returns whether the queue is empty. \"\"\" return self.s1.empty() and self.s2.empty() # Your MyQueue object will be instantiated and called as such: # obj = MyQueue() # obj.push(x) # param_2 = obj.pop() # param_3 = obj.peek() # param_4 = obj.empty() "},"chapter4/8.html":{"url":"chapter4/8.html","title":"4.8 Python数据结构常考题之堆","keywords":"","body":"4.8 Python数据结构常考题之堆 堆的常考题基本围绕在合并两个有序（数组/链表）;Topk问题 堆是完全二叉树，有最大堆和最小堆 使用Python内置的heapq模块实现堆的操作 合并k个有序链表https://leetcode.com/problems/merge-k-sorted-lists/ 读取所有链表值 构造一个最小堆heapq，很容易实现 根据最小堆构造一个链表 # Definition for singly-linked list. class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def mergeKLists(self, lists: List[ListNode]) -> ListNode: from heapq import heapify, heappop # 读取所有节点值 h = [] for node in lists: while node: h.append(node.val) node = node.next # 构造一个最小堆 heapify(h) # 转换为最小堆 # 构造链表 if not h: return None root = ListNode(heappop(h)) curnode = root while h: nextnode = ListNode(heappop(h)) curnode.next = nextnode curnode = nextnode return root "},"chapter4/9.html":{"url":"chapter4/9.html","title":"4.9 Python字符串常考题算法题","keywords":"","body":"4.9 Python字符串常考题算法题 翻转一个字符串：https://leetcode.com/problems/reverse-string/ class Solution: def reverseString(self, s: List[str]) -> None: \"\"\" Do not return anything, modify s in-place instead. \"\"\" beg = 0 end = len(s) - 1 while beg 判断一个数字是否是回文数: https://leetcode.com/problems/palindrome-number/ class Solution: def isPalindrome(self, x: int) -> bool: if x "},"chapter4/10.html":{"url":"chapter4/10.html","title":"4.10 算法与数据结构练习题反转链表","keywords":"","body":"4.10 算法与数据结构练习题反转链表 反转单链表 循环 递归 "},"chapter5/readme.html":{"url":"chapter5/readme.html","title":"第5章 编程范式考察点","keywords":"","body":"第5章 编程范式考察点 面向对象及设计模式相关知识点 "},"chapter5/1.html":{"url":"chapter5/1.html","title":"5.1 面向对象基础及Python类常考题","keywords":"","body":"5.1 面向对象基础及Python类常考题 OOP 把对象作为基本单元，把对象抽象成类，包含成员和方法 数据封装、继承、多态 优先使用组合而非继承 组合是使用其他的类示例作为自己的一个属性（has-a关系） 子类继承父类的属性和方法（is-a关系） 优先使用组合保持代码简单 之前使用stack/queue就使用到了组合 类变量和实例变量的区别 类变量由所有实例共享 实例变量由实例单独享有，不同实例之间不影响 当我们需要在一个类的实例之间共享变量的时候使用类变量 类方法和静态方法的区别 都可以通过class.method()的方式使用 类方法第一个参数是cls，可以引用类变量 静态方法使用起来和普通函数一样，只不过放在类里去组织 什么是元类？ 使用场景 元类meta class是创建类的类 元类允许我们控制类的生成，比如修改类的属性等 使用type来定义元类 元类最常见的一个使用场景就是ORM框架 class Base: pass class Child(Base): pass # 等价定义 注意Base后要加上逗号否则就不是tuple了 SameChild = type('Child', (Base,), {}) # 加上方法 class ChildWithMethod(Base): bar = True def hello(self): print('hello') def hello(self): print('hello') # 等价定义 ChildWithMethod = type( 'ChildWithMethod', (Base,), {'bar': True, 'hello': hello} ) # 元类继承自 type class LowercaseMeta(type): \"\"\" 修改类的属性名称为小写的元类 \"\"\" def __new__(mcs, name, bases, attrs): lower_attrs = {} for k, v in attrs.items(): if not k.startswith('__'): # 排除magic method lower_attrs[k.lower()] = v else: lower_attrs[k] = v return type.__new__(mcs, name, bases, lower_attrs) class LowercaseClass(metaclass=LowercaseMeta): # py3 BAR = True def HELLO(self): print('hello') print(dir(LowercaseClass)) # 你会发现\"BAR\"和\"HELLO\"都变成了小写 # 用一个类的实例调用hello方法，我们修改了类定义时候的属性名!!! LowercaseClass().hello() "},"chapter5/2.html":{"url":"chapter5/2.html","title":"5.2 装饰器面试常考题","keywords":"","body":"5.2 装饰器面试常考题 装饰器 Python中一切皆对象，函数也可以当做参数传递 装饰器是接收函数作为参数，添加功能后返回一个新函数的函数（类） Python中通过@使用装饰器 编写一个记录函数耗时的装饰器 import time def log_time(func): # 接受一个函数作为参数 def _log(*args, **kwargs): beg = time.time() res = func(*args, **kwargs) print('ues time:{}'.format(time.time() - beg)) return res return _log @log_time # @装饰器语法糖 def mysleep(): time.sleep(1) # newsleep = log_time(mysleep) # newsleep() mysleep() 使用类实现 import time class LogTime: def __call__(self, func): def _log(*args, **kwargs): beg = time.time() res = func(*args, **kwargs) print('Use time:{}'.format(time.time() - beg)) return res return _log @LogTime() def mysleep2(): time.sleep(1) mysleep2() 如何给装饰器增加参数 使用类装饰器比较方便实现装饰器参数 import time class LogTime: def __init__(self, use_int=False): self.use_int = use_int def __call__(self, func): def _log(*args, **kwargs): beg = time.time() res = func(*args, **kwargs) if self.use_int: print('use time: {}'.format(int(time.time() - beg))) else: print('use time: {}'.format(time.time() - beg)) return res return _log @LogTime(True) def mysleep(): time.sleep(1) if __name__ == '__main__': mysleep() "},"chapter5/3.html":{"url":"chapter5/3.html","title":"5.3 设计模式：创建型模式","keywords":"","body":"5.3 设计模式：创建型模式 常见创建型设计模式 工厂模式Factory：解决对象创建问题 构造模式Builder：控制复杂对象的创建 原型模式Prototype：通过原型的克隆创建新的实例 单例模式Singleton：一个类只能创建同一个对象 对象池模式Pool：预先分配同一类型的一组实例 惰性计算模式Lazy Evaluation：延迟计算（python的property） 工厂模式 解决对象创建问题 解耦对象的创建和使用 包括工厂方法和抽象工厂 # 一个工厂方法的例子 class DogToy: def speak(self): print(\"wang wang\") class CatToy: def speak(self): print(\"miao miao\") def toy_factory(toy_type): if toy_type == 'dog': return DogToy() elif toy_type == 'cat': return CatToy() 构造模式 用来控制复杂对象的构造 创建和表示分离。 比如你要买电脑，工厂模式直接给你需要的电脑 但是构造模式允许你自己定义电脑的配置，组装完成后给你 # 一个构造模式的例子 class Computer: def __init__(self, serial_number): self.serial = serial_number self.memory = None # in gigabytes self.hdd = None # in gigabytes self.gpu = None def __str__(self): info = ('Memory: {}GB'.format(self.memory), 'Hard Disk: {}GB'.format(self.hdd), 'Graphics Card: {}'.format(self.gpu)) return '\\n'.join(info) class ComputerBuilder: def __init__(self): self.computer = Computer('AG23385193') def configure_memory(self, amount): self.computer.memory = amount def configure_hdd(self, amount): self.computer.hdd = amount def configure_gpu(self, gpu_model): self.computer.gpu = gpu_model class HardwareEngineer: def __init__(self): self.builder = None def construct_computer(self, memory, hdd, gpu): self.builder = ComputerBuilder() [step for step in (self.builder.configure_memory(memory), self.builder.configure_hdd(hdd), self.builder.configure_gpu(gpu))] @property def computer(self): return self.builder.computer # 使用buidler，可以创建多个builder类实现不同的组装方式 engineer = HardwareEngineer() engineer.construct_computer(hdd=500, memory=8, gpu='GeForce GTX 650 Ti') computer = engineer.computer print(computer) 原型模式 通过克隆原型来创建新的实例 可以使用相同的原型，通过修改部分属性来创建新的实例 用途：对于一些创建实例开销比较高的地方可以使用原型模式 单例模式 一个类创建出来的对象都是同一个 Python的模块其实就是单例的，只会导入一次 使用共享同一个实例的方式来创建单例模式 # 单例模式 class Singleton: def __new__(cls, *args, **kwargs): if not hasattr(cls, '_instance'): _instance = super().__new__(cls, *args, **kwargs) cls._instance = _instance return cls._instance class MyClass(Singleton): pass c1 = MyClass() c2 = MyClass() assert c1 is c2 # 单例的，c1 c2 同一个实例 "},"chapter5/4.html":{"url":"chapter5/4.html","title":"5.4 设计模式：结构型模式","keywords":"","body":"5.4 设计模式：结构型模式 常见结构型设计模式 装饰器模式Decorator：无需子类化扩展对象功能 代理模式Proxy：把一个对象的操作代理到另一个对象，使用deque实现stack等就是 适配器模式Adapter：通过一个间接层适配统一接口 外观模式Facade：简化复杂对象的访问问题 享元模式Flyweight：通过对象复用（池）改善资源利用，比如连接池 Model-View-Controller（MVC)：解耦展示层和业务逻辑 代理模式 把一个对象的操作代理到另一个对象 这里又要提到我们之前实现的stack/Queue，把操作代理到deque 通常使用has-a组合关系 from collections import deque class Stack(object): # 使用组合的例子 def __init__(self): self._deque = deque() # has a deque() def push(self, value): return self._deque.append(value) def pop(self): return self._deque.pop() def empty(self): return len(self._deque) == 0 def __iter__(self): res = [] for i in self._deque: res.append(i) for i in reversed(res): yield i s = Stack() s.push(1) s.push(2) for i in s: print(i) 适配器模式 把不同对象的接口适配到同一个接口 想象一个多功能充电头，可以给不同的电器充电，充当了适配器 # 适配器模式的例子 class Dog(object): def __init__(self): self.name = \"Dog\" def bark(self): return \"woof!\" class Cat(object): def __init__(self): self.name = \"Cat\" def meow(self): return \"meow!\" class Adapter: def __init__(self, obj, **adapted_methods): \"\"\"We set the adapted methods in the object's dict\"\"\" self.obj = obj self.__dict__.update(adapted_methods) def __getattr__(self, attr): \"\"\"All non-adapted calls are passed to the object\"\"\" return getattr(self.obj, attr) objects = [] dog = Dog() objects.append(Adapter(dog, make_noise=dog.bark)) cat = Cat() objects.append(Adapter(cat, make_noise=cat.meow)) for obj in objects: print(\"A {0} goes {1}\".format(obj.name, obj.make_noise())) "},"chapter5/5.html":{"url":"chapter5/5.html","title":"5.5 设计模式：行为型模式","keywords":"","body":"5.5 设计模式：行为型模式 常见行为型设计模式 迭代器模式Iterator：通过统一的接口迭代对象 观察者模式Observer：对象发生改变的时候，观察者执行相应动作 策略模式Stratry：针对不同规模输入使用不同的策略 迭代器模式 Python内置对迭代器模式的支持 比如我们可以用for遍历各种Iterable的数据类型 Python里可以实现__next__和__iter__实现迭代器 观察者模式 发布订阅是一种最常见的实现方式 发布订阅用于解耦逻辑 可以通过回调等方式实现，当发生事件时，调用相应的回调函数 # 发布订阅模式 class Publisher: # 发布者 def __init__(self): self.observers = [] # 观察者 def add(self, observer): # 加入观察者 if observer not in self.observers: self.observers.append(observer) else: print('Failed to add : {}').format(observer) def remove(self, observer): # 移除观察者 try: self.observers.remove(observer) except ValueError: print('Failed to remove : {}').format(observer) def notify(self): # 调用观察者的回调 [o.notify_by(self) for o in self.observers] class Formatter(Publisher): # 继承自发布者 def __init__(self, name): super().__init__() self.name = name self._data = 0 @property def data(self): return self._data @data.setter def data(self, new_value): self._data = int(new_value) self.notify() # data 在被合法赋值以后会执行notify class BinaryFormatter: \"\"\" 订阅者 \"\"\" def notify_by(self, publisher): print(\"{}: '{}' has now bin data = {}\".format( type(self).__name__, publisher.name, bin(publisher.data)) ) def test(): df = Formatter('formatter') # 发布者 bf = BinaryFormatter() # 订阅者 df.add(bf) # 添加订阅者 df.data = 3 # 设置的时候调用订阅者的notify_by 策略模式 根据不同的输入采用不同的策略 比如买东西超过10个打八折，超过20个打七折 对外暴露统一的接口，内部采用不同的策略计算 # 策略模式 class Order: def __init__(self, price, discount_strategy=None): self.price = price self.discount_strategy = discount_strategy def price_after_discount(self): if self.discount_strategy: discount = self.discount_strategy(self) else: discount = 0 return self.price - discount def __repr__(self): fmt = \"\" return fmt.format( self.price, self.price_after_discount() ) def ten_percent_discount(order): return order.price * 0.10 def on_sale_discount(order): return order.price * 0.25 + 20 def main(): order0 = Order(100) order1 = Order(100, discount_strategy=ten_percent_discount) order2 = Order(1000, discount_strategy=on_sale_discount) print(order0) print(order1) print(order2) "},"chapter5/6.html":{"url":"chapter5/6.html","title":"5.6 Python函数式编程常考题","keywords":"","body":"5.6 Python函数式编程常考题 lambda 高阶函数map、reduce、filter 无副作用，相同的参数调用始终产生相同的结果 >>> list(map(lambda x:x*2, range(10))) [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] >>> from functools import reduce >>> reduce(lambda x,y:x+y, range(1,6)) 15 >>> list(filter(lambda x:x%2==0,range(10))) [0, 2, 4, 6, 8] >>> 什么是闭包 绑定了外部作用域的变量的函数 即使程序离开了外部作用域，如果闭包仍然可见，绑定变量不会销毁 每次运行外部函数都会重新创建闭包 闭包：引用了外部自由变量的函数 自由变量：不再当前函数定义的变量 特性：自由变量和闭包函数同时存在 "},"chapter5/7.html":{"url":"chapter5/7.html","title":"5.7 编程范式练习题：编写一个单例模式","keywords":"","body":"5.7 编程范式练习题：编写一个单例模式 使用__new__的方式实现单例模式 使用类装饰器来完成单例模式 提示：装饰器既可以接受一个函数，也可以是一个类（都是对象） "},"chapter6/readme.html":{"url":"chapter6/readme.html","title":"第6章 操作系统考察点","keywords":"","body":"第6章 操作系统考察点 linux常考命令 "},"chapter6/1.html":{"url":"chapter6/1.html","title":"6.1 面试常考Linux命令","keywords":"","body":"6.1 面试常考Linux命令 使用man查看命令帮助 使用工具自带的帮助 pip --help 介绍一个man的替代工具，tldr 使用pip install tldr安装 查看tldr tar # 查看tar的使用 文件 chown/chmod/chgrp ls/rm/cd/mv/touch/rename/ln(软链接、硬链接)等 locate/find/grep定位查找和搜索 vi/vim cat/head/tail more/less 进程 ps查看进程 kill杀死进程 top监控进程 内存 free 了解每一列的具体含义 网络 ifconfig lsof、netstat查看端口信息 ssh远程登录，scp远程赋值，tcpdump抓包 用户和组 useradd/usermod groupadd/groupmod "},"chapter6/2.html":{"url":"chapter6/2.html","title":"6.2 操作系统线程和进程常考面试题","keywords":"","body":"6.2 操作系统线程和进程常考面试题 进程和线程的区别 进程是对运行时程序的封装，是系统资源调度和分配的基本单位 线程是进程的子任务，cpu调度和分配的基本单位，实现进程内并发 一个进程可以包含多个线程，线程依赖进程存在，并共享进程内存 什么是线程安全 一个操作可以在多线程环境中安全使用，获取正确的结果 线程安全的操作好比线程顺序执行而不是并发执行的（i+=1不是线程安全的) 一般如果涉及到写操作需要考虑如何让多个线程安全访问数据 线程同步的方式 互斥量（锁）：通过互斥机制防止多个线程同时访问公共资源 信号量semphare：控制统一时刻多个线程访问同一个资源的线程数 时间（信号）：通过通知的方式保持多个线程同步 进程间通信的方式 Inter Process Communication，进程间传递信号或者数据 管道/匿名管道/有名管道（pipe） 信号（signal）：比如用户使用ctrl+c产生SIGINT程序终止信号 消息对垒（Message） 共享内存 信号量 套接字socket：最常用的方式，我们的web应用都是这种方式 Python中如何使用多线程 threading模块 threading.Thread类来创建线程 start()方法启动线程 可以用join()等待线程结束 Python中如何使用多进程 multiprocessing多进程模块 Multiprocessing.Process类实现多进程 一般用在cpu密集程序里，避免GIL的影响 # 多进程 import multiprocessing def fib(n): \"\"\"worker function\"\"\" if n "},"chapter6/3.html":{"url":"chapter6/3.html","title":"6.3 操作系统内存管理机制与Python垃圾回收","keywords":"","body":"6.3 操作系统内存管理机制与Python垃圾回收 什么是分页机制 操作系统为了高效管理内存，减少碎片 逻辑地址和物理地址分离的内存分配管理方案 程序的逻辑地址划分为固定大小的页Page 物理地址划分为同样大小的帧Frame 通过页表对应逻辑地址和物理地址 什么是分段机制 分段是为了满足代码的一些逻辑需求 数据共享，数据保护，动态链接等 通过段表实现逻辑地址和物理地址的映射关系 每个段内是连续内存分配，段和短之间是离散分配的 分页和分段的区别 页是出于内存利用率的角度提出的离散分配机制 段是出于用户角度，用于数据保护、数据隔离等用途的管理机制 页的大小是固定的，由操作系统决定；段大小不确定，用户程序决定 什么是虚拟内存 通过把一部分暂时不用的内存信息放到硬盘上 局部性原理，程序运行时候只有部分必要的信息装入内存 时间局部性和空间局部性 时间局部性：一块内存被访问，在不远的将来还可能被访问 空间局部性：一块内存被访问，它周边的内存也可能被访问 内存中暂时不需要的内容放到硬盘上 系统似乎提供了比实际内存大得多的容量，称之为虚拟内存 什么是内存抖动（颠簸） 本质是频繁的页调度行为 频繁的页调度，进程不断产出缺页中断 置换一个页，又不断再次需要这个页 运行程序太多；页面替换策略不好。终止进程或者增加物理内存 Python的垃圾回收机制原理 Python无需我们手动回收内存？它的垃圾回收是如何实现的呢？ 获取引用计数>>> import sys >>> a=[1,2] >>> sys.getrefcount(a) # 定义1次，调用1次，共两次 2 >>> b=1 >>> sys.getrefcount(1) # Python中实现小整数对象池 869 >>> 引用计数图示 引用计数为主（缺点：循环引用无法解决） 两个对象互相引用之后引用计数无法归零 循环引用图示 引入标记清楚和分代回收解决引用计数的问题 标记清除 从垃圾回收的根对象开始 不断往下查找可达对象，可达对象是一个有向图，线表示引用关系 对于不可达的点标记，后面就可以清除了 分代回收 分为三代 每代达到一定计数后开始回收 引用计数为主+标记清除和分代回收为辅 "},"chapter6/4.html":{"url":"chapter6/4.html","title":"6.4 线程练习题：多线程爬虫","keywords":"","body":"6.4 线程练习题：多线程爬虫 如何使用Python的threading模块编写多线程爬虫 使用Python的Threading模块完成一个多线程爬虫类 要求1：该类可以传入最大线程数和需要抓取的网址列表 要求2：该类可以通过继承的方式提供一个处理response的方法 "},"chapter7/readme.html":{"url":"chapter7/readme.html","title":"第7章 网络编程考察点","keywords":"","body":"第7章 网络编程考察点 网络协议TCP/UDP/HTTP常考题 "},"chapter7/1.html":{"url":"chapter7/1.html","title":"7.1 网络协议TCP和UDP面试常考题","keywords":"","body":"7.1 网络协议TCP和UDP面试常考题 浏览器输入一个URL中间经历的过程，Google详细答案 TCP三次握手过程，Google详细答案，自己会画图、状态 TCP四次挥手过程，Google详细答案，自己会画图、庄艾 TCP和UDP的区别 TCP面向连接的、可靠的、基于字节流，有缓冲区 UDP无连接的、不可靠的、面向报文，没有缓冲区 "},"chapter7/2.html":{"url":"chapter7/2.html","title":"7.2 HTTP面试常考题","keywords":"","body":"7.2 HTTP面试常考题 HTTP请求的组成 状态行 请求头（也是常考点） 消息主题 HTTP响应的组成 状态行 响应头 响应正文 HTTP常见状态码 1** 2** 3** 4** 5** HTTP GET/POST区别 GET获取、POST是创建 GET是幂等的，对数据库无影响，POST是非幂等的 GET请求参数放到URL（明文），长度有限制；POST放在请求体，更安全 什么是幂等的？哪些HTTP方法是幂等的 幂等方法是无论调用多少次都得到相同结果的HTTP方法 例如：a=4是幂等的，但是a+=4就是非幂等的 幂等的方法客户端可以安全第重发请求 安全指的是是否会修改数据 HTTP方法 是否幂等 是否安全 OPTIONS YES YES GET YES YES HEAD YES YES PUT YES NO POST NO NO DELETE YES NO PATCH NO NO HTTP长连接 短连接：建立连接...数据传输...关闭连接（连接的建立和关闭开销大） 长连接：Connection：Keep-alive。保持TCP连接不断开 如何区分不同的HTTP请求呢 Content-Length Transfer-Encoding：chunked cookie和session区别 session一般是服务器生成之后给客户端（通过url参数或cookie） cookie是实现session的一种机制，通过HTTP COOKIE字段实现 session通过在服务器保存sessionid识别用户，cookie存储在客户端 "},"chapter7/3.html":{"url":"chapter7/3.html","title":"7.3 网络编程常考题","keywords":"","body":"7.3 网络编程常考题 TCP Socket编程 客户端 import socket s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect(('127.0.0.1', 8888)) s.sendall(b'Hello World') data = s.recv(1024) print(data.decode()) s.close() 服务端 import socket import time s = socket.socket() s.bind(('', 8888)) s.listen() while True: client, addr = s.accept() # return conn, addr print(client) timestr = time.ctime(time.time()) + '\\r\\n' client.send(timestr.encode()) # send 参数 encode('utf8') client.close() 如何使用socket发送HTTP请求 使用socket接口发送HTTP请求 HTTP建立在TCP基础之上 HTTP是基于文本协议的 import socket s = socket.socket() s.connect(('www.baidu.com', 80)) http = b\"GET / HTTP/1.1\\r\\nHost: www.baidu.com\\r\\n\\r\\n\" s.sendall(http) buf = s.recv(1024) print(buf) s.close() "},"chapter7/4.html":{"url":"chapter7/4.html","title":"7.4 并发编程IO多路复用常见考题","keywords":"","body":"7.4 并发编程IO多路复用常见考题 Unix网络编程中提到的5中网络模型 Blocking IO Nonblocking IO IO Multiplexing Signal Driven IO Asynchronous IO 后两种不常用，一般使用IO多路复用比较多 如何提升服务器的并发能力呢？ 多线程模型，创建新的线程处理请求 多进程模型，创建新的进程处理请求 线程和进程比较占用资源，难以同时创建太多 现在基本采用IO多路复用，实现单进程同时处理多个socket请求 什么是IO多路复用 操作系统提供的同时监听多个socket的机制 为了实现高并发需要一种机制并发处理多个socket Linux常见的是select、poll、epoll 可以使用单线程、单进程处理多个socket 为什么select可以实现IO多路复用 阻塞IO的流程 IO多路复用的流程 select、poll、epoll区别（了解，前两个O(n)，最后一个O(1)) Python如何实现IO多路复用 "},"chapter7/5.html":{"url":"chapter7/5.html","title":"7.5 Python并发网络库常考题","keywords":"","body":"7.5 Python并发网络库常考题 并发网络库 Tornado：并发网络库和同时也是一个web微框架 Gevent：绿色线程greenlet实现并发，猴子补丁修改内置socket Asyncio：Python3内置的并发网络库，基于原生协议 Tornado框架 适用于微服务，实现Restful接口 底层基于Linux多路复用 可通过协程或者回调实现异步编程 不过生态不完善，相应的异步框架比如ORM不完善 import tornado.ioloop import tornado.web from tornado.httpclient import AsyncHTTPClient class APIHandler(tornado.web.RequestHandler): async def get(self): url = 'http://httpbin.org/get' http_client = AsyncHTTPClient() resp = await http_client.fetch(url) print(resp.body) return resp.body def make_app(): return tornado.web.Application([ (r\"/api\", APIHandler), ]) if __name__ == \"__main__\": app = make_app() app.listen(8888) tornado.ioloop.IOLoop.current().start() gevent 高性能的并发网络库 基于轻量级绿色线程greenlet实现并发 需要注意monkey patch，gevent修改了内置的socket改为非阻塞 配合gunicorn和gevent部署作为wsgi server,参考 import gevent.monkey gevent.monkey.patch_all() # 修改内置的一些库非阻塞 import gevent import requests def fetch(i): url = 'http://httpbin.org/get' resp = requests.get(url) print(len(resp.text), i) def asynchronous(): threads = [] for i in range(1, 10): threads.append(gevent.spawn(fetch, i)) gevent.joinall(threads) print('Asynchronous:') asynchronous() Asyncio 基于协程实现的内置并发网络库 Python3引入到内置库，协程+事件循环 生态不够完善，没有大规模生产环境检验 目前应用不够广泛，基于Aiohttp可以实现一些小的服务 # 基于 aiohttp 并发请求 import asyncio from aiohttp import ClientSession # pip install aiohttp async def fetch(url, session): async with session.get(url) as response: return await response.read() async def run(r=10): url = \"http://httpbin.org/get\" tasks = [] async with ClientSession() as session: for i in range(r): task = asyncio.ensure_future(fetch(url, session)) tasks.append(task) responses = await asyncio.gather(*tasks) for resp_body in responses: print(len(resp_body)) loop = asyncio.get_event_loop() future = asyncio.ensure_future(run()) loop.run_until_complete(future) pip install httpie分析报文 "},"chapter7/6.html":{"url":"chapter7/6.html","title":"7.6 异步框架练习题：异步爬虫","keywords":"","body":"7.6 异步框架练习题：异步爬虫 可以选择asyncio，编写一个异步爬虫类 要求1：该类可以传入需要抓取的网址列表 要求2：该类可以通过继承的方式提供一个处理response的方法 "},"chapter8/readme.html":{"url":"chapter8/readme.html","title":"第8章 数据库考察点","keywords":"","body":"第8章 数据库考察点 数据库考察点 "},"chapter8/1.html":{"url":"chapter8/1.html","title":"8.1 MySQL基础常考题","keywords":"","body":"8.1 MySQL基础常考题 考点 事务的原理，特性，事务并发控制 常用的字段、含义和区别 常用的数据库引擎之间的区别 什么是事务 Transaction 事务是数据库并发控制的基本单位 事务可以看做是一系列SQL语句的集合 事务必须要么全部执行成功，要么全部执行失败（回滚） 转账操作是事务使用的一个常见场景 事务的ACID特性 原子性Atomicity：一个事务中所有操作全部完成或失败 一致性Consistency：事务开始和结束之后数据完整性没有被破坏 隔离性Isolation：允许多个是事务同时对数据库修改和读写 持久性Durability：事务结束之后，修改时永久的不会丢失 事务的并发控制可能产生哪些问题 如果不对事务进行并发控制，可能会产生四种异常情况 幻读：一个事务第二次查出现第一次没有的结果 非重复读：一个事务重复读两次得到不同的结果 脏读：一个事务读到另一个事务没有提交的修改 丢失修改：并发写入造成其中一些修改丢失 四种事务隔离级别 待补充 待补充 待补充 待补充 如何解决高并发场景下的插入重复 高并发场景下，写入数据库会有数据重复问题 使用数据库的唯一索引 使用队列异步写入 使用redis等实现分布式锁 乐观锁和悲观锁 乐观锁 悲观锁 MySQL常用数据类型 字符串 数值 日期和时间 InnoDB和MyISAM MyISAM不支持事务，InnoDB支持事务 MyISAM不支持外键，InnoDB支持外键 MyISAM只支持表锁，InnoDB支持行锁和表锁 "},"chapter8/2.html":{"url":"chapter8/2.html","title":"8.2 MySQL索引优化常考题","keywords":"","body":"8.2 MySQL索引优化常考题 为什么需要索引？ 索引是数据表中一个或者多个列进行排序的数据结构 索引能够大幅度提高检索速度 创建、更新索引本身也会耗费空间和时间 为什么要用BTree？ 线性查找：一个个找；实现简单，太慢 二分查找：有序；简单；要求是有序的，插入特别慢 HASH：查询快，占用空间，不太适合存储大规模数据 二叉查找数：插入和查询很快，logn，无法存大规模数据，复杂度退化 平衡树：解决bst退化的问题，树是平衡的，节点非常多的时候，依然树高很高（每个节点只有两个孩子） 多路查找树：一个父亲多个孩子节点（度），节点过多时，树高不会特变深 多路平衡查找树：BTree 什么是BTree 多路平衡查找树，每个节点最多m个孩子，m>=2,称为m阶或者度 叶节点具有相同的深度 节点中的数据key从左到右是递增的 B+树是BTtree的变形 ... MySQL创建索引类型 普通索引 唯一索引 多列索引 主键索引 全文索引 什么时候创建索引 建表的时候需要根据查询需求来创建索引 经常用作查询条件的字段where条件 经常用作表连接的字段 经常出现在order by、group by之后的字段 创建索引有哪些需要注意的？ 非空字段Not NULL,MySQL很难对空值做查询优化 。。。 索引什么时候失效 。。 。。 。。 什么是聚集索引和非聚集索引 。。 。。 如何排查慢查询 。。 。。 "},"chapter8/3.html":{"url":"chapter8/3.html","title":"8.3 SQL语句编写常考题","keywords":"","body":"8.3 SQL语句编写常考题 常用考点 SQL语句以考察各种常用连接为重点 内连接 外连接 全连接 内连接 。。 外连接 左连接 右连接 全连接 。。 "},"chapter8/4.html":{"url":"chapter8/4.html","title":"8.4 缓存机制及Redis常考面试题","keywords":"","body":"8.4 缓存机制及Redis常考面试题 "},"chapter8/5.html":{"url":"chapter8/5.html","title":"8.5 数据库练习题：MySQL索引与Redis","keywords":"","body":"8.5 数据库练习题：MySQL索引与Redis "},"chapter9/readme.html":{"url":"chapter9/readme.html","title":"第9章 Python Web框架考察点","keywords":"","body":"第9章 Python Web框架考察点 "},"chapter9/1.html":{"url":"chapter9/1.html","title":"9.1 Python WSGI与Web框架考点","keywords":"","body":"9.1 Python WSGI与Web框架考点 "},"chapter9/2.html":{"url":"chapter9/2.html","title":"9.2 Web安全考察点","keywords":"","body":"9.2 Web安全考察点 "},"chapter9/3.html":{"url":"chapter9/3.html","title":"9.3 前后端分离与RESTful常见面试题","keywords":"","body":"9.3 前后端分离与RESTful常见面试题 "},"chapter9/4.html":{"url":"chapter9/4.html","title":"9.4 Web安全思考题：什么是HTTPS","keywords":"","body":"9.4 Web安全思考题：什么是HTTPS "},"chapter10/readme.html":{"url":"chapter10/readme.html","title":"第10章 系统设计考察点","keywords":"","body":"第10章 系统设计考察点 "},"chapter10/1.html":{"url":"chapter10/1.html","title":"10.1 系统设计考点解析","keywords":"","body":"10.1 系统设计考点解析 "},"chapter10/2.html":{"url":"chapter10/2.html","title":"10.2 系统设计真题解析","keywords":"","body":"10.2 系统设计真题解析 "},"chapter10/3.html":{"url":"chapter10/3.html","title":"10.3 系统设计思考题","keywords":"","body":"10.3 系统设计思考题 "},"chapter11/readme.html":{"url":"chapter11/readme.html","title":"第11章 面试经验分享","keywords":"","body":"第11章 面试经验分享 "},"chapter11/1.html":{"url":"chapter11/1.html","title":"11.1 面试经验分享","keywords":"","body":"11.1 面试经验分享 "},"chapter12/readme.html":{"url":"chapter12/readme.html","title":"第12章 课程总结","keywords":"","body":"第12章 课程总结 "},"chapter12/1.html":{"url":"chapter12/1.html","title":"12.1 课程总结","keywords":"","body":"12.1 课程总结 "}}